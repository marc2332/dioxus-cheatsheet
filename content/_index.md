+++
title = "ü¶Ä Dioxus Framework Cheatsheet"
insert_anchor_links = "left"
in_search_index = true
+++


<noprint>
<toc><column>

**Components**
* [Components](#components)
* [Props](#props)
* [RSX](#rsx)

**State**
* [Local](#local-state)
* [Shared](#shared-state)
* [Global](#global-state)

**Hooks**
* [Rules](#components)
* [Custom](#components)

</column>

<column>

**Dioxus Standard Library**
* [Color Scheme](#components)
* [Localization (i18n)](#components)
* [Channels](#components)

**Renderers**
* [Web](#components)
* [Desktop](#components)
* [TUI](#components)
* [Blitz](#components)
* [Liveview](#components)
* [Freya](#components)

**Patterns**
* [Composition](#components)
* [Memoization](#components)

</column>
</toc>
</noprint>

<noprint>

### Overview

**Dioxus** is a declarative library for building user interfaces (UI) in Rust ü¶Ä. It is inspired by React, so it shares many of it's concepts like **Components** and **Hooks**. Dioxus is renderer agnostic, so you can use it with any renderer that is available, for instance, there are renderers for web (WASM), Desktop (Webview), TUI, Blitz (WGPU), LiveView, Freya (non-official Skia renderer).

### Components

**Components** are the building blocks of your application. They encapsulate contain the declared UI of your app.
In Dioxus they are expressed in the form of functions.

```rust
fn Component(cx: Scope) -> Element {
    render!(
        div {
            "Hello World"
        }	
    )
}
```

As you can see, the `Component` function takes a `Scope` as an argument and returns an `Element`. 

* **Scopes** are unique to their components. This is why you will need to pass it to **Hooks** when calling them.
* **Element** is the representation of your UI that will be generated by the `render!()` macro.


## RSX

RSX is a special syntax used to declare the UI, don't worry, it integrates quite well with Rust.

```rust
fn Component(cx: Scope) -> Element {
    let some_value = 123;

    render!(
        button { // A button element
            width: "100%", // An attribute
            onclick: |evt| println!("{evt:?}"), // An event listener
            p { // A nested element
                height: "20px",
                "Value is {some_value}" // A text node
            }
        }	
    )
}
```

### Local State

Components can have local state, this is useful for storing data that is only relevant to the component itself. This can be archived by using the `use_state` or `use_ref` hooks.

#### `use_state`

The `use_state` hook is used to store data that will change over time. It takes an initial value and returns a `UseState` object.

Every time you modify the state, the component will be re-run.

```rust
fn Component(cx: Scope) -> Element {
    let counter = use_state(cx, || 0);

    // This will be printed every time the state changes 
    println!("{counter}");

    let onclick = |_| {
        // You can use the normal operators to update the state
        counter += 1;

        // Or you can use the set and get functions
        counter.set(counter.get() + 1);
        
        // You can also use the modify function
        counter.modify(|counter| counter + 1);

        // You can also use the with_mut function
        counter.modify(|counter| *counter += 1);
    };

    render!(
        button {
            onclick: onclick,
            "{counter}"
        }	
    )
}
```

#### `use_ref`

The use_ref hook is used to store data that will change over time. It takes an initial value and returns a `UseRef` object. 
The difference with `use_state` is that `use_ref` can be modified without re-running the component, which can be useful when you need to hold a value across renders that is used asynchronously.

```rust
fn Component(cx: Scope) -> Element {
    let counter = use_ref(cx, || 0);

    let onclick = |_| {
        // Silently increment the counter, this will not make the component re-run
        counter.write_silent() = counter.read() + 1;
    };

    let double_and_update = |_| {
        // Double the counter, this will make the component re-run
        counter.write() = counter.read() * 2;
    };

    render!(
        button {
            onclick: increment_silently,
            "Increment Silently"
        }
        p {
            "{counter}"
        }
        button {
            onclick: double_and_update,
            "Double and update"
        }
    )
}
```

### Shared State
Shared state is used to store data that is shared across components. This can be archived by using the `use_shared_state` and `use_shared_state_provider` hooks.


#### `use_shared_state_provider`

You can use `use_shared_state_provider` to share a certain value all the way down to it's children. 

```rust

#[derive(Debug, Clone)]
enum Theme {
    Light,
    Dark
}

fn App(cx: Scope) -> Element {
    // All the children of this component will have access to this shared state
    // See `use_shared_state` on how to actually read it
    use_shared_state_provider(cx, || Theme::Dark);

    render!(
         CoolChild {}
    )
}
```

#### `use_shared_state`

You can use `use_shared_state` to share a certain value all the way down to it's children. 

```rust

#[derive(Debug, Clone)]
enum Theme {
    Light,
    Dark
}

fn CoolChild(cx: Scope) -> Element {
    // We can know access the shared state that was provided by the parent
    let theme = use_shared_state::<Theme>(cx);

    // You can read it with the read function
    let is_light = theme.read() == Theme::Light;

    let onclick = |_| {
        theme.write() = match theme.read() {
            Theme::Light => Theme::Dark,
            Theme::Dark => Theme::Light
        };
    };

    render!(
         button {
            onclick: onclick,
            "Click to toggle the theme: {theme:?}"
         }
    )
}
```

### Global State


### Providers
Providers are usually Hooks/Components that provide a certain value down to all it's children

Example:

```rust

fn App(cx: Scope) -> Element {
    render!(
        // Only Components that are desdendants of ThemeProvider will have access to the state
        ThemeProvider {
            CoolContainer { // ‚úÖ Will have access
                CoolButton { // ‚úÖ Will have access
                    "Hello World"
                }
            }
        }
        NotCoolText { // ‚ùå Will not have access
            "This text is not cool"
        }
    )
}
```

### Props

Props are parameters for Components, but they are different to normal function arguments:
- Can be optional
- Can have default types
- Can be memoized

Props as struct:

```rust
#[derive(Props)]
struct CoolProps {
    value: i32
}

fn CoolValue(cx: Scope<CoolProps>) -> Element {
    let value = cx.props.value;
    render!(
        p {
            "Value: {value}"
        }	
    )
}

fn Component(cx: Scope) -> Element {
    let value = use_state(cx, || 0);
    render!(
        button {
            onclick: |evt| { 
                value += 1;
            },
            CoolValue {
                value: *value.get()
            }
        }	
    )
}
```

Inline props:
    
```rust
#[inline_props]
fn CoolValue(cx: Scope, value: i32) -> Element {
    render!(
        p {
            "Value: {value}"
        }	
    )
}

fn Component(cx: Scope) -> Element {
    let value = use_state(cx, || 0);
    render!(
        button {
            onclick: |evt| { 
                value += 1;
            },
            CoolValue {
                value: *value.get()
            }
        }	
    )
}
```

Props with event handlers:

```rust
struct CoolEvent {
    value: i32
}

#[derive(Props)]
struct CoolProps<'a> {
    value: i32,
    oncoolevent: EventHandler<'a, CoolEvent>
}

fn CoolValue(cx: Scope<CoolProps>) -> Element {
    let value = cx.props.value;
    render!(
        button {
            onclick: |_| cx.props.oncoolevent.call(CoolEvent { value: value + 1}),
            "Value: {value}"
        }	
    )
}

fn Component(cx: Scope) -> Element {
    let value = use_state(cx, || 0);
    render!(
        CoolValue {
            oncoolevent: |evt| { 
                value.set(evt.value)
            },
            value: *value.get()
        }
    )
}
```


Optional props:

```rust

#[derive(Props)]
struct CoolProps<'a> {
    #[props(optional)]
    value: Option<i32>,
}

fn CoolValue(cx: Scope<CoolProps>) -> Element {
    let value = cx.props.value.unwrap_or(123);
    render!(
        p {
            "Value: {value}"
        }	
    )
}

fn Component(cx: Scope) -> Element {
    render!(
        CoolValue { }	
    )
}
```

Optional props with default values:

```rust
#[derive(Props)]
struct CoolProps<'a> {
    #[props(optional, default = 123)]
    value: i32,
}

fn CoolValue(cx: Scope<CoolProps>) -> Element {
    let value = cx.props.value;
    render!(
        p {
            "Value: {value}"
        }	
    )
}

fn Component(cx: Scope) -> Element {
    render!(
        CoolValue { }	
    )
}
```

Auto convert prop values:

```rust
#[derive(Props)]
struct CoolProps<'a> {
    #[props(into)]
    text: String,
}

fn CoolValue(cx: Scope<CoolProps>) -> Element {
    let text = cx.props.text;
    render!(
        p {
            "text: {text}"
        }	
    )
}

fn Component(cx: Scope) -> Element {
    render!(
        CoolValue {
            text: "Hello World"
        }	
    )
}
```


### Hooks
Hooks are functions that allow you to do certain things in your components. They are usually prefixed with `use_`. Because they are simple functions you can create your own hooks:

```rust
#[derive(Clone)]
struct UseCounter {
    state: UseState<i32>
}

impl UseCounter {
    fn increment(&self) {
        self.state.set(self.state.get() + 1);
    }

    fn value(&self) -> i32 {
        *self.state.get()
    }
}

fn use_counter(cx: ScopeState) -> UseCounter {
    let state = use_state(cx, || 0);
    UseCounter { state }
}

fn Component(cx: Scope) -> Element {
    let counter = use_counter();

    render!(
        button {
            onclick: |_| counter.increment(),
            "{counter.value()}"
        }
    )
}
```

### Composition

### Memoization

### Localization

### Channels